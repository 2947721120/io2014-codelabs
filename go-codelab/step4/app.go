//  Package todo is an App Engine app providing a REST API to manage todo
//  lists.
//
//  The REST API provides the following handlers:
//
//  /api/auth GET
//    Current authentication state for the user requesting.
//
//  /api/lists GET
//    Gets all the list names and ids and creators if no user is logged in.
//    If the user is logged in, only their lists.
//  /api/lists POST
//    Creates a new list.
//  /api/list/{list} GET
//    Gets the name, creator, and id of a list with id {list}.
//  /api/list/{list} DELETE
//    Deletes the list with id {list}.
//
package todo

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"

	"github.com/gorilla/mux"

	"appengine"
	"appengine/datastore"
)

const (
	// datastore entity kind for users
	userKind = "User"
	// datastore entity kind for List
	listKind = "List"
)

// List represents a lists of tasks.
type List struct {
	// Autogenerated id, not stored in the datastore.
	ID string `datastore:"-"`

	Name string // Name of the list
}

func init() {
	// Register all the handlers.
	r := mux.NewRouter().PathPrefix("/api/").Subrouter()

	// Auth management
	r.Handle("/auth", appHandler(authHandler))

	// List management
	r.Handle("/list", appHandler(getAllLists)).Methods("GET")
	r.Handle("/list", appHandler(createList)).Methods("POST")
	r.Handle("/list/{list}", appHandler(getList)).Methods("GET")
	r.Handle("/list/{list}", appHandler(deleteList)).Methods("DELETE")

	http.Handle("/api/", r)
}

// authHandler encodes the current user email and the urls to log in and out as
// a JSON object in the http response.
func authHandler(w io.Writer, r *http.Request) error {
	return errors.New("authHandler not implemented")

	// Obtain the urls that users should follow to log in and out.
	// If there's a user currently logged in obtain its email.
	// Then encode all that data as a JSON object into the given io.Writer
	// - user.LoginURL : http://golang.org/s/users#LoginURL
	// - user.LogoutURL : http://golang.org/s/users#LogoutURL
	// - user.Current : http://golang.org/s/users#Current
}

// getAllLists fetches all the lists in the datastore and encodes them
// in JSON format into the http response.
func getAllLists(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// If the user is logged in fetch only their lists.
	// - user.Current : http://golang.org/s/users#Current
	// - Query.Ancestor : http://golang.org/s/datastore#Query.Ancestor

	lists := []List{}
	keys, err := datastore.NewQuery(listKind).GetAll(c, &lists)
	if err != nil {
		return fmt.Errorf("fetch all lists: %v", err)
	}

	// Update the encoded keys and encode the lists.
	for i, k := range keys {
		lists[i].ID = k.Encode()
	}
	return json.NewEncoder(w).Encode(lists)
}

// createList creates a new list. It reads a JSON encoded list from the request
// body.
func createList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Check that the user is logged in.
	// - user.Current : http://golang.org/s/users#Current

	// Decode a list from the request body.
	list := List{}
	err := json.NewDecoder(r.Body).Decode(&list)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "decode list: %v", err)
	}

	if list.Name == "" {
		return appErrorf(http.StatusBadRequest, "missing list name")
	}

	// Set the Creator field of list as the email of the current user.

	// Put the List in the datastore.
	key := datastore.NewIncompleteKey(c, listKind, nil)
	key, err = datastore.Put(c, key, &list)
	if err != nil {
		return fmt.Errorf("create list: %v", err)
	}

	// Update the encoded key and encode the list.
	list.ID = key.Encode()
	return json.NewEncoder(w).Encode(list)
}

// getList fetches the list with the id given in the url and encodes it in
// JSON format into the http response.
func getList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list id from the URL.
	id := mux.Vars(r)["list"]

	// Decode the obtained id into a datastore key.
	key, err := datastore.DecodeKey(id)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch the list from the datastore.
	list := &List{}
	err = datastore.Get(c, key, list)
	if err == datastore.ErrNoSuchEntity {
		return appErrorf(http.StatusNotFound, "list not found")
	}
	if err != nil {
		return fmt.Errorf("fetch list: %v", err)
	}

	// Set the ID field with the id from the request url and encode the list.
	list.ID = id
	return json.NewEncoder(w).Encode(&list)
}

// deleteList deletes the list with the id given in the url.
func deleteList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	key, err := datastore.DecodeKey(mux.Vars(r)["list"])
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Check that the current user is the creator of the list.
	// - Key.Parent : http://golang.org/s/datastore#Key.Parent
	// - Key.StringID : http://golang.org/s/datastore#Key.StringID

	// Delete the list.
	return datastore.Delete(c, key)
}
