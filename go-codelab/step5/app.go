//  Package todo is an App Engine app providing a REST API to manage todo
//  lists.
//
//  The REST API provides the following handlers:
//
//  /api/auth GET
//    Current authentication state for the user requesting.
//
//  /api/lists GET
//    Gets all the list names and ids and creators if no user is logged in.
//    If the user is logged in, only their lists.
//  /api/lists POST
//    Creates a new list.
//  /api/list/{list} GET
//    Gets the name, creator, and id of a list with id {list}.
//  /api/list/{list} DELETE
//    Deletes the list with id {list}.
//
//  /api/lists/{list}/tasks GET
//    Lists all the tasks in the list with id {list}.
//  /api/lists/{list}/tasks POST
//    Adds the task sent as POST data in the list with id {list}.
//  /api/lists/{list}/tasks/{task} UPDATE
//    Updates the task with {task} in the list with id {list} with the task
//    sent as POST data.
//
package todo

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/gorilla/mux"

	"appengine"
	"appengine/datastore"
	"appengine/user"
)

const (
	// datastore entity kind to identify users.
	userKind = "User"
	// datastore entity kind for List
	listKind = "List"
	// datastore entity kind for Task
	taskKind = "Task"
)

// List represents a lists of tasks.
type List struct {
	// Autogenerated id, not stored in the datastore.
	ID string `datastore:"-"`

	Name    string // Name of the list
	Creator string // Email of the user that created this list
}

// Task represents an task in a todo list.
type Task struct {
	// Autogenerated id, not stored in the datastore.
	ID int64 `datastore:"-"`

	Text string // Text describing the task
	Done bool   // Completion state of the task.
	Time int64  // UnixTime used to sort the tasks chronologically.
}

func init() {
	// Register all the handlers.
	r := mux.NewRouter().PathPrefix("/api/").Subrouter()

	// Authentication data.
	r.Handle("/auth", appHandler(authHandler)).Methods("GET")

	// List management
	r.Handle("/list", appHandler(getAllLists)).Methods("GET")
	r.Handle("/list", authReq(createList)).Methods("POST")
	r.Handle("/list/{list}", appHandler(getList)).Methods("GET")
	r.Handle("/list/{list}", authReq(deleteList)).Methods("DELETE")

	// Task management.
	r.Handle("/list/{list}/task", appHandler(getTasks)).Methods("GET")
	r.Handle("/list/{list}/task", authReq(createTask)).Methods("POST")
	r.Handle("/list/{list}/task/{task}", authReq(updateTask)).Methods("PATCH")

	http.Handle("/api/", r)
}

// authHandler encodes the current user email and the urls to log in and out as
// a JSON object in the http response.
func authHandler(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)
	login, err := user.LoginURL(c, "/")
	if err != nil {
		return err
	}
	logout, err := user.LogoutURL(c, "/")
	if err != nil {
		return err
	}
	reply := struct{ User, Login, Logout string }{
		Login:  login,
		Logout: logout,
	}
	if u := user.Current(c); u != nil {
		reply.User = u.Email
	}
	return json.NewEncoder(w).Encode(reply)
}

// getAllLists fetches all the lists of the logged in user and encodes them
// in JSON format into the http response.
// If no user is logged in all lists are returned instead.
func getAllLists(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	query := datastore.NewQuery(listKind)
	// If the user is logged in fetch only their lists.
	if u := user.Current(c); u != nil {
		userKey := datastore.NewKey(c, userKind, u.Email, 0, nil)
		query = query.Ancestor(userKey)
	}

	lists := []List{}
	keys, err := query.GetAll(c, &lists)
	if err != nil {
		return fmt.Errorf("fetch all lists: %v", err)
	}

	// Update the encoded keys and encode the lists.
	for i, k := range keys {
		lists[i].ID = k.Encode()
	}
	return json.NewEncoder(w).Encode(lists)
}

// createList creates a new list. It reads a JSON encoded list from the request
// body and checks that the user is logged in.
func createList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode a list from the request body.
	list := List{}
	err := json.NewDecoder(r.Body).Decode(&list)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "decode list: %v", err)
	}
	list.Creator = user.Current(c).Email

	// Put the List in the datastore.
	userKey := datastore.NewKey(c, userKind, list.Creator, 0, nil)
	key := datastore.NewIncompleteKey(c, listKind, userKey)
	key, err = datastore.Put(c, key, &list)
	if err != nil {
		return fmt.Errorf("create list: %v", err)
	}

	// Update the encoded key and encode the list.
	list.ID = key.Encode()
	return json.NewEncoder(w).Encode(list)
}

// getList fetches the list with the id given in the url and encodes it in
// JSON format into the http response.
func getList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list id from the URL.
	id := mux.Vars(r)["list"]

	// Decode the obtained id into a datastore key.
	key, err := datastore.DecodeKey(id)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch the list from the datastore.
	list := &List{}
	err = datastore.Get(c, key, list)
	if err == datastore.ErrNoSuchEntity {
		return appErrorf(http.StatusNotFound, "list not found")
	}
	if err != nil {
		return fmt.Errorf("fetch list: %v", err)
	}

	// Set the ID field with the id from the request url and encode the list.
	list.ID = id
	return json.NewEncoder(w).Encode(&list)
}

// decode decodes a key from the given list id and finds the email of the creator
// of the list, which corresponds to the StringID of the ancestor key.
func decode(listID string) (list *datastore.Key, email string, err error) {
	// Decode the obtained id into a datastore key.
	list, err = datastore.DecodeKey(listID)
	if err != nil {
		return nil, "", appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Check that the logged in user is the creator of the list.
	user := list.Parent()
	if user == nil {
		return nil, "", appErrorf(http.StatusBadRequest, "list missing parent")
	}
	return list, user.StringID(), nil
}

// deleteList deletes the list with the id given in the url if the user is
// logged in and is the creator of the list.
func deleteList(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	key, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return appErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	c.Infof("deleting list with key %v", key)

	// TODO
	// Do all fo the rest in a single transaction, so either everything is
	// delete or nothing.
	// - RunInTransaction: http://golang.org/s/datastore#RunInTransaction

	// Find the keys of all the tasks in the list using an ancestor query.
	// - Query.Ancestor: http://golang.org/s/datastore#Query.Ancestor
	// - Query.KeysOnly: http://golang.org/s/datastore#Query.KeysOnly

	// Delete all the tasks in a single operation.
	// - DeleteMulti: http://golang.org/s/datastore#DeleteMulti

	// Delete the list itself.
	// - Delete: http://golang.org/s/datastore#Delete

	return errors.New("not implemented")
}

// getTasks fetches all the tasks in the list with the id given in the url and
// encodes them in JSON format into the http response.
func getTasks(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Get the list key from the url and decode it.
	listKey, err := datastore.DecodeKey(mux.Vars(r)["list"])
	if err != nil {
		return appErrorf(http.StatusBadRequest, "invalid list id")
	}

	// Fetch all the tasks from datastore.
	tasks := []Task{}
	keys, err := datastore.NewQuery(taskKind).Ancestor(listKey).GetAll(c, &tasks)
	if err != nil {
		return fmt.Errorf("fetch tasks: %v", err)
	}

	// Update the encoded keys and encode the tasks.
	for i, key := range keys {
		tasks[i].ID = key.IntID()
	}
	return json.NewEncoder(w).Encode(tasks)
}

// createTask parses a task from the request body in JSON format and adds it to
// the list with the id given in the url. Finally it encodes the created task
// with the generated id into the http response.
func createTask(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	listKey, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return appErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	// Decode the task from the request body.
	task := Task{}
	err = json.NewDecoder(r.Body).Decode(&task)
	if err != nil {
		return appErrorf(http.StatusBadRequest, "decode task: %v", err)
	}
	if task.Text == "" {
		return appErrorf(http.StatusBadRequest, "missing task text")
	}

	// Set the creation time in the task and put it in the datastore.
	task.Time = time.Now().Unix()
	key := datastore.NewIncompleteKey(c, taskKind, listKey)
	key, err = datastore.Put(c, key, &task)
	if err != nil {
		return fmt.Errorf("add task: %v", err)
	}

	// Add the encoded key before encoding the task to JSON.
	task.ID = key.IntID()
	return json.NewEncoder(w).Encode(task)
}

// updateTask parses a task from the request body in JSON format and updates
// the task identified by the url in the datastore.
func updateTask(w io.Writer, r *http.Request) error {
	c := appengine.NewContext(r)

	// Decode the list id in the URL and check the current user is the creator.
	listKey, creator, err := decode(mux.Vars(r)["list"])
	if err != nil {
		return err
	}
	if creator != user.Current(c).Email {
		return appErrorf(http.StatusForbidden, "only %v can do this", creator)
	}

	c.Infof("updating task in list with key %v", listKey)

	// TODO
	// Parse the string in the url identified by "task".
	// - mux.Vars: http://godoc.org/github.com/gorilla/mux#Vars
	// - strconv.ParseInt: http://godoc.org/strconv#ParseInt

	// Decode a Task from the http request body.

	// Fetch the task with correpsonding key from the datastore.
	// If it doesn't exist fail with http.StatusNotFound.
	// Update the Done field of the task in the datastore.
	// And save it back into the datastore.

	return errors.New("not implemented")
}
